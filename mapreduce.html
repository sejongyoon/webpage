<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapReduce 대화형 분석</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Visualization & Content Choices: 
        - 실행 흐름 (논문 그림 1): 목표 - MapReduce의 복잡한 단계별 과정을 쉽게 이해하도록 지원. 표현 - HTML/CSS/JS 기반 대화형 다이어그램. 상호작용 - 주요 구성요소(입력 분할, 마스터, 맵 워커, 중간 파일, 리듀스 워커, 출력 파일) 클릭 시 설명 툴팁 표시. 정당성 - 정적 이미지보다 참여적이며, 사용자가 자신의 속도에 맞춰 학습 가능. 라이브러리/방법 - HTML/CSS, JS.
        - 성능 데이터 (논문 그림 2, 3): 목표 - 다양한 조건에서의 MapReduce 성능 특성을 시각적으로 전달. 표현 - Chart.js를 사용한 선형 차트. 정렬 작업의 경우 '일반 실행', '백업 작업 없음', '작업자 실패' 시나리오 간 전환 버튼 제공. 상호작용 - 차트 포인트에 마우스 오버 시 정확한 값 표시, 시나리오 전환 버튼. 정당성 - Chart.js는 명확하고 반응형인 차트 생성에 적합하며, 토글 기능은 복잡함 없이 시나리오 비교를 용이하게 함. 라이브러리/방법 - Chart.js.
        - 구글 사용 통계 (논문 표 1): 목표 - MapReduce의 실제 사용 규모 강조. 표현 - 깔끔하게 스타일링된 HTML 표. 상호작용 - 없음. 정당성 - 구조화된 데이터를 가장 직접적으로 보여줌. 라이브러리/방법 - HTML/Tailwind CSS.
        - MapReduce 인스턴스 증가 (논문 그림 4): 목표 - MapReduce 채택 추세 시각화. 표현 - Chart.js 선형 차트. 상호작용 - 마우스 오버 툴팁. 정당성 - 시간 경과에 따른 추세 표시에 효과적. 라이브러리/방법 - Chart.js.
        - 고급 기능 (논문 섹션 4): 목표 - MapReduce를 향상시키는 다양한 기능 설명. 표현 - 각 기능(파티셔닝 함수, 결합자 함수 등)이 아이템인 아코디언 UI. 상호작용 - 아코디언 헤더 클릭 시 세부 정보(설명, 필요한 경우 의사 코드) 확장. 정당성 - 여러 정보를 깔끔하게 정리하고 정보 과부하 방지. 라이브러리/방법 - HTML/Tailwind, JS.
    -->
    <style>
        body { font-family: 'Inter', sans-serif; scroll-behavior: smooth; }
        .section-title { font-size: 1.75rem; font-weight: 600; margin-bottom: 1rem; color: #0f769e; } /* sky-700 */
        .subsection-title { font-size: 1.25rem; font-weight: 500; margin-bottom: 0.75rem; color: #0b5c7c; } /* sky-800 */
        .content-text { line-height: 1.75; margin-bottom: 1rem; color: #374151; } /* slate-700 */
        .interactive-diagram-item { cursor: pointer; transition: transform 0.2s ease-in-out; }
        .interactive-diagram-item:hover { transform: scale(1.05); }
        .chart-container { position: relative; width: 100%; max-width: 700px; margin-left: auto; margin-right: auto; height: 350px; max-height: 400px; padding: 1rem; border-radius: 0.5rem; background-color: #f0f9ff; } /* sky-50 */
        @media (min-width: 768px) { .chart-container { height: 400px; } }
        .tooltip { visibility: hidden; background-color: #334155; color: white; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 10; bottom: 125%; left: 50%; margin-left: -100px; opacity: 0; transition: opacity 0.3s; width: 200px; font-size: 0.875rem; }
        .interactive-diagram-item:hover .tooltip { visibility: visible; opacity: 1; }
        .nav-link { padding: 0.5rem 1rem; border-radius: 0.375rem; transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out; }
        .nav-link:hover, .nav-link.active { background-color: #0ea5e9; color: white; } /* sky-500 */
        .nav-link.active { font-weight: 600; }
        .code-block { background-color: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; margin-bottom: 1rem; }
        .table-container { max-width: 800px; margin: 1rem auto; overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #e5e7eb; padding: 0.75rem; text-align: left; } /* gray-200 */
        th { background-color: #f3f4f6; font-weight: 600; } /* gray-100 */
        .tab-button { padding: 0.5rem 1rem; margin-right: 0.5rem; border-radius: 0.375rem; cursor: pointer; background-color: #e0f2fe; color: #0c4a6e; } /* sky-100, sky-800 */
        .tab-button.active { background-color: #0ea5e9; color: white; font-weight: 600; } /* sky-500 */
        .tab-content { display: none; padding: 1rem; border: 1px solid #e0f2fe; border-radius: 0.375rem; margin-top: 0.5rem; } /* sky-100 */
        .tab-content.active { display: block; }
        .accordion-button { background-color: #f0f9ff; color: #075985; padding: 0.75rem 1rem; width: 100%; text-align: left; border: none; border-bottom: 1px solid #e0f2fe; cursor: pointer; transition: background-color 0.3s; font-weight: 500; }
        .accordion-button:hover { background-color: #e0f2fe; }
        .accordion-content { padding: 0 1rem; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; background-color: #f8fafc; }
        .accordion-content.active { max-height: 500px; /* Adjust as needed */ padding: 1rem; }
    </style>
</head>
<body class="bg-amber-50 text-slate-800">

    <header class="bg-sky-700 text-white shadow-md sticky top-0 z-50">
        <nav class="container mx-auto px-6 py-3 flex flex-wrap justify-center items-center">
            <h1 class="text-2xl font-bold mr-6">MapReduce 심층 분석</h1>
            <div class="flex flex-wrap justify-center space-x-1 md:space-x-2 mt-2 md:mt-0 text-sm md:text-base">
                <a href="#overview" class="nav-link">개요</a>
                <a href="#core-concepts" class="nav-link">핵심 원리</a>
                <a href="#implementation" class="nav-link">구현</a>
                <a href="#refinements" class="nav-link">고급 기능</a>
                <a href="#performance" class="nav-link">성능</a>
                <a href="#experience" class="nav-link">활용 사례</a>
                <a href="#conclusion" class="nav-link">결론</a>
            </div>
        </nav>
    </header>

    <main class="container mx-auto px-6 py-8">
        <section id="overview" class="pt-16 -mt-16">
            <h2 class="section-title">1. 개요: MapReduce란 무엇인가?</h2>
            <p class="content-text">
                이 섹션에서는 MapReduce가 무엇이며, 대규모 데이터 처리 문제 해결에 왜 중요한지에 대해 설명합니다. MapReduce는 구글에서 대용량 데이터셋을 처리하고 생성하기 위해 개발한 프로그래밍 모델이자 관련 구현체입니다. 이 모델을 사용하면 프로그래머는 분산 및 병렬 시스템의 복잡한 세부 사항을 알 필요 없이 대규모 계산을 쉽게 수행할 수 있습니다.
            </p>
            <div class="grid md:grid-cols-2 gap-6 bg-white p-6 rounded-lg shadow">
                <div>
                    <h3 class="subsection-title">핵심 아이디어</h3>
                    <p class="content-text">MapReduce의 핵심은 사용자가 'Map'과 'Reduce'라는 두 가지 함수만 정의하면, 시스템이 자동으로 데이터를 분할하고, 여러 기계에 작업을 분산시키며, 오류를 처리하고, 기계 간 통신을 관리한다는 것입니다. 이를 통해 프로그래머는 데이터 처리 로직 자체에만 집중할 수 있습니다.</p>
                </div>
                <div>
                    <h3 class="subsection-title">필요성</h3>
                    <p class="content-text">웹 문서, 로그 파일 등과 같이 엄청난 양의 원시 데이터를 처리하여 유용한 정보를 추출해야 하는 경우가 많습니다. 기존 방식으로는 이러한 데이터를 처리하는 데 많은 시간과 노력이 필요했고, 병렬 처리, 데이터 분산, 오류 처리 등을 직접 구현해야 하는 복잡성이 있었습니다. MapReduce는 이러한 복잡성을 추상화하여 대규모 데이터 처리를 간소화합니다.</p>
                </div>
            </div>
        </section>

        <section id="core-concepts" class="pt-16 -mt-16">
            <h2 class="section-title">2. 핵심 원리</h2>
            <p class="content-text">
                MapReduce 모델은 두 가지 주요 함수, 즉 Map 함수와 Reduce 함수를 기반으로 합니다. 이 섹션에서는 이 두 함수의 역할과 예시, 그리고 전체적인 MapReduce 작업 실행 흐름을 자세히 살펴봅니다.
            </p>
            <div class="bg-white p-6 rounded-lg shadow mb-6">
                <h3 class="subsection-title">2.1 프로그래밍 모델</h3>
                <div class="grid md:grid-cols-2 gap-4">
                    <div>
                        <h4 class="font-semibold text-lg mb-2 text-sky-700">Map 함수</h4>
                        <p class="content-text">입력 키/값 쌍을 처리하여 중간 키/값 쌍의 집합을 생성합니다. 예를 들어, 문서 모음에서 각 단어의 출현 빈도를 계산하는 경우, Map 함수는 각 단어를 키로, 숫자 1을 값으로 하는 쌍을 생성할 수 있습니다 (예: `(단어, 1)`).</p>
                    </div>
                    <div>
                        <h4 class="font-semibold text-lg mb-2 text-sky-700">Reduce 함수</h4>
                        <p class="content-text">동일한 중간 키와 관련된 모든 중간 값들을 병합합니다. 단어 빈도 계산 예시에서 Reduce 함수는 특정 단어에 대한 모든 '1' 값들을 합산하여 해당 단어의 총 빈도를 계산합니다 (예: `(단어, 총빈도수)`).</p>
                    </div>
                </div>
                <h4 class="font-semibold text-lg my-2 text-sky-700">예시: 단어 빈도 계산 (의사 코드)</h4>
                <div class="code-block">
map(String key, String value):
  // key: 문서 이름
  // value: 문서 내용
  for each word w in value:
    EmitIntermediate(w, "1");

reduce(String key, Iterator values):
  // key: 단어
  // values: 빈도수 목록 ('1'들의 목록)
  int result = 0;
  for each v in values:
    result += ParseInt(v);
  Emit(AsString(result));
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow">
                <h3 class="subsection-title">2.2 실행 개요 (대화형 다이어그램)</h3>
                <p class="content-text mb-4">아래 다이어그램은 MapReduce 작업의 전체적인 실행 흐름을 보여줍니다. 각 구성 요소를 클릭하면 간단한 설명을 볼 수 있습니다.</p>
                <div class="relative p-4 border border-sky-200 rounded-lg bg-sky-50 text-center">
                    <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-center">
                        <div id="diag-input" class="interactive-diagram-item bg-amber-200 p-3 rounded-md shadow">
                            입력 파일<br>(분할됨: M개)
                            <span class="tooltip">입력 데이터는 M개의 스플릿으로 나뉘어 병렬 처리됩니다.</span>
                        </div>
                        <div class="text-2xl font-bold text-sky-600">&rarr;</div>
                        <div id="diag-map" class="interactive-diagram-item bg-green-200 p-3 rounded-md shadow">
                            Map 단계<br>(M개 Map 작업)
                            <span class="tooltip">각 Map 워커는 할당된 입력 스플릿을 읽고 Map 함수를 실행하여 중간 키/값 쌍을 생성합니다.</span>
                        </div>
                        <div class="text-2xl font-bold text-sky-600">&rarr;</div>
                        <div id="diag-intermediate" class="interactive-diagram-item bg-yellow-200 p-3 rounded-md shadow">
                            중간 파일<br>(로컬 디스크, R개 영역)
                            <span class="tooltip">Map 작업의 결과는 파티셔닝 함수에 의해 R개의 리전으로 나뉘어 로컬 디스크에 저장됩니다.</span>
                        </div>
                    </div>
                    <div class="my-4 text-2xl font-bold text-sky-600 text-center md:hidden">&darr;</div>
                    <div class="my-4 text-2xl font-bold text-sky-600 hidden md:block md:text-right md:pr-20">&crarr; (Shuffle & Sort)</div>
                     <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-center mt-4 md:mt-0">
                        <div id="diag-output" class="interactive-diagram-item bg-purple-200 p-3 rounded-md shadow md:col-start-5">
                            출력 파일<br>(R개)
                             <span class="tooltip">Reduce 작업의 최종 결과는 R개의 출력 파일에 저장됩니다.</span>
                        </div>
                         <div class="text-2xl font-bold text-sky-600 md:col-start-4 text-right">&larr;</div>
                        <div id="diag-reduce" class="interactive-diagram-item bg-blue-200 p-3 rounded-md shadow md:col-start-3">
                            Reduce 단계<br>(R개 Reduce 작업)
                             <span class="tooltip">Reduce 워커는 관련된 중간 데이터를 읽고 정렬한 후 Reduce 함수를 실행하여 최종 결과를 생성합니다.</span>
                        </div>
                        <div class="text-2xl font-bold text-sky-600 hidden md:block">&larr;</div>
                         <div class="hidden md:block"></div>
                    </div>
                     <div id="diag-master" class="absolute top-[-20px] left-1/2 transform -translate-x-1/2 interactive-diagram-item bg-red-200 p-2 rounded-full shadow-lg text-sm">
                        마스터
                        <span class="tooltip">마스터는 전체 작업을 조율하고, 워커에게 작업을 할당하며, 상태를 모니터링합니다.</span>
                    </div>
                </div>
                <p class="content-text mt-4">
                    1.  **입력 분할:** 입력 파일이 M개의 조각(스플릿)으로 나뉩니다.
                    2.  **Map 작업 할당:** 마스터는 M개의 Map 작업을 유휴 워커들에게 할당합니다.
                    3.  **Map 함수 실행:** Map 워커는 입력 스플릿을 읽고 Map 함수를 적용하여 중간 키/값 쌍을 생성합니다.
                    4.  **중간 데이터 로컬 저장:** 생성된 중간 쌍은 로컬 디스크에 R개의 리전으로 파티셔닝되어 저장됩니다. 위치 정보는 마스터에게 전달됩니다.
                    5.  **Reduce 작업 할당:** 마스터는 R개의 Reduce 작업을 유휴 워커들에게 할당하고, 중간 데이터 위치를 알려줍니다.
                    6.  **데이터 읽기 (Shuffle):** Reduce 워커는 Map 워커의 로컬 디스크에서 자신에게 할당된 중간 데이터를 원격으로 읽어옵니다.
                    7.  **데이터 정렬 (Sort):** Reduce 워커는 읽어온 중간 데이터를 키 기준으로 정렬합니다.
                    8.  **Reduce 함수 실행:** 정렬된 데이터에 대해 고유한 각 키별로 Reduce 함수를 적용하여 최종 출력을 생성합니다.
                    9.  **출력 저장:** Reduce 함수의 출력은 R개의 최종 출력 파일에 저장됩니다.
                </p>
            </div>
        </section>

        <section id="implementation" class="pt-16 -mt-16">
            <h2 class="section-title">3. 구현 세부사항</h2>
            <p class="content-text">
                이 섹션에서는 MapReduce 시스템의 구체적인 구현 방식과 주요 특징들을 설명합니다. 여기에는 마스터와 워커의 역할, 내결함성 메커니즘, 데이터 지역성 최적화, 작업 세분성, 그리고 지연 작업자 문제를 해결하기 위한 백업 작업 등이 포함됩니다. 이러한 요소들이 어떻게 상호작용하여 안정적이고 효율적인 대규모 데이터 처리를 가능하게 하는지 살펴봅니다.
            </p>
            <div class="space-y-6">
                <div class="bg-white p-6 rounded-lg shadow">
                    <h3 class="subsection-title">3.1 마스터 데이터 구조</h3>
                    <p class="content-text">마스터는 각 Map 작업과 Reduce 작업의 상태(유휴, 진행 중, 완료)와 할당된 워커 머신의 ID를 저장합니다. 또한, 완료된 Map 작업이 생성한 R개의 중간 파일 리전의 위치와 크기를 저장하여 Reduce 워커에게 전달합니다.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow">
                    <h3 class="subsection-title">3.2 내결함성 (Fault Tolerance)</h3>
                    <ul class="list-disc list-inside content-text space-y-2">
                        <li><strong>워커 고장:</strong> 마스터는 주기적으로 워커를 핑(ping)하여 상태를 확인합니다. 응답이 없으면 워커를 고장으로 간주하고, 해당 워커가 수행 중이던 작업(Map 또는 Reduce)이나 완료한 Map 작업(출력이 로컬 디스크에 있어 접근 불가)을 유휴 상태로 되돌려 다른 워커에게 재할당합니다. 완료된 Reduce 작업은 전역 파일 시스템에 결과가 저장되므로 재실행할 필요가 없습니다.</li>
                        <li><strong>마스터 고장:</strong> 마스터는 주기적으로 자신의 데이터 구조를 체크포인트로 저장하여, 고장 시 마지막 체크포인트에서 복구할 수 있습니다. (논문 당시 구현은 마스터 실패 시 계산 중단, 클라이언트 재시도)</li>
                        <li><strong>고장 시 의미론:</strong> Map/Reduce 연산자가 결정론적이면, 분산 구현은 오류 없는 순차 실행과 동일한 출력을 생성합니다. 이는 작업 출력을 임시 파일에 쓰고 완료 시 원자적으로 최종 파일로 이름을 바꾸어 보장합니다.</li>
                    </ul>
                </div>
                <div class="bg-white p-6 rounded-lg shadow">
                    <h3 class="subsection-title">3.3 데이터 지역성 (Locality)</h3>
                    <p class="content-text">네트워크 대역폭은 제한된 자원이므로, GFS(Google File System)에 저장된 입력 데이터의 위치 정보를 활용합니다. 마스터는 Map 작업을 해당 데이터의 복제본이 있는 머신이나 가까운 머신에 스케줄링하려고 시도합니다. 이를 통해 대부분의 입력 데이터가 로컬 디스크에서 읽혀 네트워크 사용량을 최소화합니다.</p>
                </div>
                 <div class="bg-white p-6 rounded-lg shadow">
                    <h3 class="subsection-title">3.4 작업 세분성 (Task Granularity)</h3>
                    <p class="content-text">Map 단계는 M개, Reduce 단계는 R개의 조각으로 나눕니다. 이상적으로 M과 R은 워커 머신 수보다 훨씬 커야 합니다. 각 워커가 많은 다른 작업을 수행하면 동적 로드 밸런싱이 향상되고 워커 장애 시 복구가 빨라집니다 (완료된 많은 Map 작업을 다른 모든 워커 머신에 분산 가능). 실제로는 마스터가 O(M+R)개의 스케줄링 결정을 내리고 O(M*R) 상태를 메모리에 유지해야 하므로 M과 R의 크기에는 현실적인 한계가 있습니다.</p>
                </div>
                 <div class="bg-white p-6 rounded-lg shadow">
                    <h3 class="subsection-title">3.5 백업 작업 (Backup Tasks)</h3>
                    <p class="content-text">전체 MapReduce 작업 시간을 길게 만드는 일반적인 원인 중 하나는 '지연 작업자(straggler)'입니다. 이는 디스크 불량, 다른 작업과의 리소스 경쟁 등 다양한 이유로 발생할 수 있습니다. MapReduce 작업이 거의 완료될 무렵, 마스터는 남아있는 진행 중인 작업의 백업 실행을 스케줄링합니다. 기본 실행이나 백업 실행 중 먼저 완료되는 쪽의 결과를 사용합니다. 이 메커니즘은 전체 완료 시간을 크게 단축시킵니다.</p>
                </div>
            </div>
        </section>

        <section id="refinements" class="pt-16 -mt-16">
            <h2 class="section-title">4. 고급 기능 (Refinements)</h2>
            <p class="content-text">
                기본적인 Map 및 Reduce 함수 외에도 MapReduce 라이브러리는 실제 사용에 유용한 몇 가지 확장 기능을 제공합니다. 이 섹션에서는 파티셔닝 함수, 정렬 보장, 결합자 함수, 다양한 입출력 유형 지원, 오류 레코드 처리, 로컬 실행 모드, 상태 정보 제공, 그리고 카운터 기능 등 MapReduce의 유용성과 편의성을 높이는 다양한 개선 사항들을 소개합니다.
            </p>
            <div id="accordion-container" class="space-y-1">
                <div>
                    <button class="accordion-button">4.1 파티셔닝 함수 (Partitioning Function)</button>
                    <div class="accordion-content">
                        <p class="content-text">사용자는 R개의 Reduce 작업/출력 파일 수를 지정합니다. 데이터는 중간 키에 대한 파티셔닝 함수를 사용하여 이 작업들 간에 분할됩니다. 기본 파티셔닝 함수는 해싱(예: "hash(key) mod R")을 사용합니다. 경우에 따라 다른 키 함수로 데이터를 파티셔닝하는 것이 유용할 수 있습니다(예: 모든 URL이 동일한 호스트에서 동일한 출력 파일에 저장되도록 "hash(Hostname(urlkey)) mod R" 사용).</p>
                    </div>
                </div>
                <div>
                    <button class="accordion-button">4.2 정렬 보장 (Ordering Guarantees)</button>
                    <div class="accordion-content">
                        <p class="content-text">주어진 파티션 내에서 중간 키/값 쌍이 증가하는 키 순서로 처리됨을 보장합니다. 이 정렬 보장은 파티션별로 정렬된 출력 파일을 쉽게 생성할 수 있게 하며, 이는 출력 파일 형식이 키에 의한 효율적인 랜덤 접근 조회를 지원해야 하거나 사용자가 정렬된 데이터를 편리하게 사용할 때 유용합니다.</p>
                    </div>
                </div>
                <div>
                    <button class="accordion-button">4.3 결합자 함수 (Combiner Function)</button>
                    <div class="accordion-content">
                        <p class="content-text">각 Map 작업에서 생성된 중간 키에 상당한 반복이 있고 사용자 지정 Reduce 함수가 교환 및 결합 법칙을 만족하는 경우(예: 단어 빈도수 계산) 유용합니다. 사용자는 선택적으로 Combiner 함수를 지정하여 데이터가 네트워크를 통해 전송되기 전에 부분 병합을 수행할 수 있습니다. Combiner 함수는 Map 작업을 수행하는 각 머신에서 실행되며, 일반적으로 Combiner와 Reduce 함수에 동일한 코드가 사용됩니다. 부분 결합은 특정 유형의 MapReduce 작업 속도를 크게 향상시킵니다.</p>
                    </div>
                </div>
                <div>
                    <button class="accordion-button">4.4 입력 및 출력 유형</button>
                    <div class="accordion-content">
                        <p class="content-text">라이브러리는 여러 다른 형식의 입력 데이터 읽기를 지원합니다(예: "텍스트" 모드 입력은 각 줄을 키/값 쌍으로 처리). 각 입력 유형 구현은 개별 Map 작업으로 처리하기 위한 의미 있는 범위로 자신을 분할하는 방법을 알고 있습니다. 사용자는 간단한 리더 인터페이스를 구현하여 새 입력 유형에 대한 지원을 추가할 수 있습니다. 유사하게, 다른 형식으로 데이터를 생성하기 위한 출력 유형 집합을 지원하며 사용자가 새 출력 유형을 쉽게 추가할 수 있습니다.</p>
                    </div>
                </div>
                 <div>
                    <button class="accordion-button">4.5 부작용 (Side-effects)</button>
                    <div class="accordion-content">
                        <p class="content-text">경우에 따라 사용자는 Map 및/또는 Reduce 연산자의 추가 출력으로 보조 파일을 생성하는 것이 편리하다고 생각합니다. 이러한 부작용을 원자적이고 멱등적이게 만드는 것은 애플리케이션 작성자의 책임입니다. 일반적으로 애플리케이션은 임시 파일에 쓰고 완전히 생성되면 이 파일을 원자적으로 이름을 바꿉니다. 단일 작업에 의해 생성된 여러 출력 파일의 원자적 2단계 커밋은 지원하지 않습니다.</p>
                    </div>
                </div>
                <div>
                    <button class="accordion-button">4.6 오류 레코드 건너뛰기</button>
                    <div class="accordion-content">
                        <p class="content-text">사용자 코드의 버그로 인해 특정 레코드에서 Map 또는 Reduce 함수가 결정론적으로 충돌하여 MapReduce 작업 완료를 방해할 수 있습니다. 이 경우, MapReduce 라이브러리가 결정론적 충돌을 일으키는 레코드를 감지하고 이러한 레코드를 건너뛰어 진행할 수 있는 선택적 실행 모드를 제공합니다. 각 워커 프로세스는 세그멘테이션 오류 및 버스 오류를 포착하는 신호 처리기를 설치합니다. 사용자 코드가 신호를 생성하면 신호 처리기는 인수의 시퀀스 번호가 포함된 "마지막 숨결" UDP 패킷을 마스터로 보냅니다. 마스터가 특정 레코드에서 두 번 이상의 실패를 확인하면 해당 Map 또는 Reduce 작업의 다음 재실행을 발행할 때 해당 레코드를 건너뛰도록 지시합니다.</p>
                    </div>
                </div>
                <div>
                    <button class="accordion-button">4.7 로컬 실행</button>
                    <div class="accordion-content">
                        <p class="content-text">Map 또는 Reduce 함수의 문제 디버깅은 실제 계산이 분산 시스템에서 발생하기 때문에 까다로울 수 있습니다. 디버깅, 프로파일링 및 소규모 테스트를 용이하게 하기 위해 MapReduce 라이브러리의 대체 구현을 개발하여 로컬 머신에서 MapReduce 작업의 모든 작업을 순차적으로 실행합니다. 사용자는 특별한 플래그로 프로그램을 호출한 다음 유용한 디버깅 또는 테스트 도구(예: gdb)를 쉽게 사용할 수 있습니다.</p>
                    </div>
                </div>
                 <div>
                    <button class="accordion-button">4.8 상태 정보</button>
                    <div class="accordion-content">
                        <p class="content-text">마스터는 내부 HTTP 서버를 실행하고 사람이 볼 수 있는 상태 페이지 집합을 내보냅니다. 상태 페이지에는 완료된 작업 수, 진행 중인 작업 수, 입력 바이트, 중간 데이터 바이트, 출력 바이트, 처리 속도 등과 같은 계산 진행 상황이 표시됩니다. 또한 각 작업에서 생성된 표준 오류 및 표준 출력 파일에 대한 링크도 포함됩니다. 사용자는 이 데이터를 사용하여 계산에 걸리는 시간을 예측하고 계산에 더 많은 리소스를 추가해야 하는지 여부를 결정할 수 있습니다. 또한 예상보다 계산이 훨씬 느릴 때 원인을 파악하는 데 사용할 수 있습니다.</p>
                    </div>
                </div>
                <div>
                    <button class="accordion-button">4.9 카운터 (Counters)</button>
                    <div class="accordion-content">
                        <p class="content-text">MapReduce 라이브러리는 다양한 이벤트 발생 횟수를 계산하는 카운터 기능을 제공합니다(예: 처리된 총 단어 수 또는 색인된 독일어 문서 수). 사용자 코드는 명명된 카운터 객체를 만들고 Map 및/또는 Reduce 함수에서 카운터를 적절히 증가시킵니다. 개별 워커 머신의 카운터 값은 주기적으로 마스터로 전파됩니다. 마스터는 성공한 Map 및 Reduce 작업의 카운터 값을 집계하여 MapReduce 작업이 완료될 때 사용자 코드에 반환합니다. 현재 카운터 값은 마스터 상태 페이지에도 표시됩니다.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="performance" class="pt-16 -mt-16">
            <h2 class="section-title">5. 성능</h2>
            <p class="content-text">
                이 섹션에서는 대규모 클러스터에서 실행되는 두 가지 계산(Grep 및 Sort)에 대한 MapReduce의 성능을 측정합니다. 이러한 프로그램들은 MapReduce 사용자들이 작성하는 실제 프로그램의 대표적인 예시로, 하나는 데이터를 한 표현에서 다른 표현으로 섞는 작업이고, 다른 하나는 대규모 데이터셋에서 소량의 관심 데이터를 추출하는 작업입니다. 성능 측정은 논문에 제시된 클러스터 환경에서 이루어졌습니다.
            </p>
            <div class="bg-white p-6 rounded-lg shadow mb-6">
                <h3 class="subsection-title">5.1 클러스터 구성</h3>
                <ul class="list-disc list-inside content-text">
                    <li>머신 수: 약 1800대</li>
                    <li>프로세서: 2GHz Intel Xeon (하이퍼스레딩 활성화) 2개</li>
                    <li>메모리: 머신당 4GB (약 1-1.5GB는 다른 작업용으로 예약됨)</li>
                    <li>디스크: 160GB IDE 디스크 2개</li>
                    <li>네트워크: 기가비트 이더넷</li>
                    <li>네트워크 구조: 2단계 트리형 스위치 네트워크 (루트에서 약 100-200 Gbps 총 대역폭)</li>
                </ul>
            </div>

            <div class="bg-white p-6 rounded-lg shadow mb-6">
                <h3 class="subsection-title">5.2 Grep 성능</h3>
                <p class="content-text">Grep 프로그램은 $10^{10}$개의 100바이트 레코드(약 1TB)를 스캔하여 상대적으로 드문 3문자 패턴을 검색합니다 (패턴은 92,337개 레코드에서 발생). 입력은 약 64MB 조각(M=15000)으로 분할되고 전체 출력은 하나의 파일(R=1)에 저장됩니다.</p>
                <div class="chart-container">
                    <canvas id="grepChart"></canvas>
                </div>
                <p class="content-text mt-2">위 차트는 시간 경과에 따른 Grep 작업의 입력 데이터 스캔 속도를 보여줍니다. 속도는 점차 증가하여 1764개의 워커가 할당되었을 때 30GB/s 이상으로 최고점에 도달합니다. Map 작업이 완료됨에 따라 속도는 감소하기 시작하여 약 80초 후에 0이 됩니다. 전체 계산은 시작부터 완료까지 약 150초가 소요되며, 여기에는 약 1분의 시작 오버헤드가 포함됩니다.</p>
            </div>

            <div class="bg-white p-6 rounded-lg shadow">
                <h3 class="subsection-title">5.3 Sort 성능</h3>
                <p class="content-text">Sort 프로그램은 $10^{10}$개의 100바이트 레코드(약 1TB)를 정렬합니다. 입력 데이터는 64MB 조각(M=15000)으로 분할되고, 정렬된 출력은 4000개의 파일(R=4000)로 파티셔닝됩니다.</p>
                <div class="mb-4">
                    <button id="sortNormalBtn" class="tab-button active">일반 실행</button>
                    <button id="sortNoBackupBtn" class="tab-button">백업 작업 없음</button>
                    <button id="sortKilledBtn" class="tab-button">200개 작업자 실패</button>
                </div>
                <div id="sortChartNormalContainer" class="tab-content active">
                    <p class="content-text font-semibold mb-2">일반 실행 (논문 그림 3a):</p>
                    <div class="grid md:grid-cols-3 gap-4">
                        <div class="chart-container"><canvas id="sortInputChartNormal"></canvas></div>
                        <div class="chart-container"><canvas id="sortShuffleChartNormal"></canvas></div>
                        <div class="chart-container"><canvas id="sortOutputChartNormal"></canvas></div>
                    </div>
                     <p class="content-text mt-2">입력 속도는 약 13GB/s에서 최고조에 달하며 모든 Map 작업이 200초 이내에 완료됩니다. 셔플 속도는 첫 번째 Map 작업이 완료되자마자 시작됩니다. 정렬된 데이터 쓰기는 약 350초부터 시작하여 약 850초에 완료됩니다. 전체 계산 시간은 891초입니다.</p>
                </div>
                <div id="sortChartNoBackupContainer" class="tab-content">
                    <p class="content-text font-semibold mb-2">백업 작업 비활성화 시 (논문 그림 3b):</p>
                     <div class="grid md:grid-cols-3 gap-4">
                        <div class="chart-container"><canvas id="sortInputChartNoBackup"></canvas></div>
                        <div class="chart-container"><canvas id="sortShuffleChartNoBackup"></canvas></div>
                        <div class="chart-container"><canvas id="sortOutputChartNoBackup"></canvas></div>
                    </div>
                    <p class="content-text mt-2">실행 흐름은 유사하지만, 쓰기 활동이 거의 없는 매우 긴 꼬리가 있습니다. 마지막 몇몇 지연 작업자로 인해 전체 계산 시간이 1283초로 44% 증가합니다.</p>
                </div>
                <div id="sortChartKilledContainer" class="tab-content">
                    <p class="content-text font-semibold mb-2">200개 작업자 프로세스 강제 종료 시 (논문 그림 3c):</p>
                     <div class="grid md:grid-cols-3 gap-4">
                        <div class="chart-container"><canvas id="sortInputChartKilled"></canvas></div>
                        <div class="chart-container"><canvas id="sortShuffleChartKilled"></canvas></div>
                        <div class="chart-container"><canvas id="sortOutputChartKilled"></canvas></div>
                    </div>
                    <p class="content-text mt-2">일부 Map 작업이 사라져 재실행되면서 입력 속도가 음수로 나타납니다. Map 작업 재실행은 비교적 빠르게 이루어집니다. 전체 계산은 933초에 완료되어 정상 실행 시간보다 5%만 증가합니다.</p>
                </div>
            </div>
        </section>

        <section id="experience" class="pt-16 -mt-16">
            <h2 class="section-title">6. 활용 사례 및 경험</h2>
            <p class="content-text">
                MapReduce는 구글 내 다양한 영역에서 성공적으로 활용되었습니다. 이 섹션에서는 MapReduce의 광범위한 적용 분야, 사용 통계, 그리고 구글 웹 검색 서비스의 프로덕션 인덱싱 시스템 재작성에 MapReduce를 사용함으로써 얻은 이점들을 소개합니다. 이를 통해 MapReduce가 실제 대규모 문제 해결에 얼마나 효과적인지 알 수 있습니다.
            </p>
            <div class="bg-white p-6 rounded-lg shadow mb-6">
                <h3 class="subsection-title">6.1 구글 내 사용 현황 (2004년 9월 기준)</h3>
                 <p class="content-text">MapReduce는 대규모 머신러닝 문제, Google 뉴스 및 Froogle 제품을 위한 클러스터링 문제, 인기 검색어 보고서(예: Google Zeitgeist) 생성을 위한 데이터 추출, 지역화된 검색을 위한 웹 페이지의 지리적 위치 추출, 대규모 그래프 계산 등 다양한 분야에 활용되었습니다.</p>
                <div class="chart-container">
                    <canvas id="instancesChart"></canvas>
                </div>
                <p class="content-text mt-2">위 차트는 2003년 초부터 2004년 9월 말까지 구글의 기본 소스 코드 관리 시스템에 등록된 개별 MapReduce 프로그램 수의 상당한 증가를 보여줍니다. 이는 개발 및 프로토타이핑 주기를 크게 단축시키고 분산/병렬 시스템 경험이 없는 프로그래머도 대규모 리소스를 쉽게 활용할 수 있게 해주었기 때문입니다.</p>

                <h4 class="font-semibold text-lg my-3 text-sky-700">2004년 8월 MapReduce 작업 통계 (일부)</h4>
                <div class="table-container">
                    <table id="statsTable">
                        <thead>
                            <tr><th>항목</th><th>값</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>총 작업 수</td><td>29,423</td></tr>
                            <tr><td>평균 작업 완료 시간</td><td>634 초</td></tr>
                            <tr><td>사용된 머신 일수</td><td>79,186 일</td></tr>
                            <tr><td>읽은 입력 데이터</td><td>3,288 TB</td></tr>
                            <tr><td>생성된 중간 데이터</td><td>758 TB</td></tr>
                            <tr><td>쓰여진 출력 데이터</td><td>193 TB</td></tr>
                            <tr><td>작업당 평균 워커 머신 수</td><td>157</td></tr>
                            <tr><td>작업당 평균 워커 장애 수</td><td>1.2</td></tr>
                            <tr><td>작업당 평균 Map 작업 수</td><td>3,351</td></tr>
                            <tr><td>작업당 평균 Reduce 작업 수</td><td>55</td></tr>
                            <tr><td>고유 Map 구현 수</td><td>395</td></tr>
                            <tr><td>고유 Reduce 구현 수</td><td>269</td></tr>
                            <tr><td>고유 Map/Reduce 조합 수</td><td>426</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="bg-white p-6 rounded-lg shadow">
                <h3 class="subsection-title">6.2 대규모 인덱싱</h3>
                <p class="content-text">MapReduce의 가장 중요한 용도 중 하나는 Google 웹 검색 서비스에 사용되는 데이터 구조를 생성하는 프로덕션 인덱싱 시스템의 완전한 재작성이었습니다. 인덱싱 시스템은 크롤링 시스템에서 검색한 방대한 문서 집합(원시 콘텐츠 20TB 이상)을 입력으로 사용합니다. 인덱싱 프로세스는 5~10개의 MapReduce 작업 시퀀스로 실행됩니다. 이전 버전의 임시 분산 처리 방식 대신 MapReduce를 사용함으로써 다음과 같은 여러 이점을 얻었습니다.</p>
                <ul class="list-disc list-inside content-text space-y-2">
                    <li><strong>코드 단순화 및 축소:</strong> 내결함성, 분산 및 병렬화를 처리하는 코드가 MapReduce 라이브러리 내에 숨겨져 있어 인덱싱 코드가 더 간단해지고, 작아졌으며, 이해하기 쉬워졌습니다. (예: 한 계산 단계의 C++ 코드 크기가 약 3800줄에서 약 700줄로 감소)</li>
                    <li><strong>유연성 증가:</strong> 개념적으로 관련 없는 계산을 데이터에 대한 추가 통과를 피하기 위해 함께 섞는 대신 분리하여 유지할 수 있게 되어 인덱싱 프로세스 변경이 용이해졌습니다. (예: 이전 시스템에서 몇 달 걸리던 변경 사항이 새 시스템에서는 며칠 만에 구현 가능)</li>
                    <li><strong>운영 용이성 향상:</strong> 머신 장애, 느린 머신, 네트워킹 문제로 인한 대부분의 문제가 운영자 개입 없이 MapReduce 라이브러리에 의해 자동으로 처리됩니다. 또한 인덱싱 클러스터에 새 머신을 추가하여 인덱싱 프로세스의 성능을 쉽게 향상시킬 수 있습니다.</li>
                </ul>
            </div>
        </section>

        <section id="conclusion" class="pt-16 -mt-16">
            <h2 class="section-title">7. 결론 및 교훈</h2>
            <p class="content-text">
                MapReduce 프로그래밍 모델은 구글에서 다양한 목적으로 성공적으로 사용되었습니다. 이 섹션에서는 MapReduce의 성공 요인과 이 작업을 통해 얻은 중요한 교훈들을 요약합니다. 이러한 교훈들은 대규모 분산 시스템 설계 및 구현에 있어 귀중한 통찰력을 제공합니다.
            </p>
            <div class="grid md:grid-cols-2 gap-6">
                <div class="bg-white p-6 rounded-lg shadow">
                    <h3 class="subsection-title">성공 요인</h3>
                    <ul class="list-disc list-inside content-text space-y-2">
                        <li><strong>사용 편의성:</strong> 병렬화, 내결함성, 지역성 최적화, 로드 밸런싱의 세부 사항을 숨겨 병렬 및 분산 시스템 경험이 없는 프로그래머도 쉽게 사용할 수 있습니다.</li>
                        <li><strong>광범위한 적용성:</strong> Google의 프로덕션 웹 검색 서비스용 데이터 생성, 정렬, 데이터 마이닝, 머신러닝 등 다양한 문제를 MapReduce 계산으로 쉽게 표현할 수 있습니다.</li>
                        <li><strong>확장성:</strong> 수천 대의 머신으로 구성된 대규모 클러스터로 확장 가능하며, 이러한 머신 리소스를 효율적으로 사용합니다.</li>
                    </ul>
                </div>
                 <div class="bg-white p-6 rounded-lg shadow">
                    <h3 class="subsection-title">주요 교훈</h3>
                    <ul class="list-disc list-inside content-text space-y-2">
                        <li>프로그래밍 모델을 제한하면 계산을 병렬화하고 분산시키며 내결함성을 갖추기 쉽습니다.</li>
                        <li>네트워크 대역폭은 부족한 자원입니다. 데이터 지역성 최적화 및 중간 데이터의 단일 복사본을 로컬 디스크에 쓰는 것은 네트워크를 통해 전송되는 데이터 양을 줄이는 데 중요합니다.</li>
                        <li>중복 실행(백업 작업)을 사용하여 느린 머신의 영향을 줄이고 머신 장애 및 데이터 손실을 처리할 수 있습니다.</li>
                    </ul>
                </div>
            </div>
        </section>
    </main>

    <footer class="bg-sky-800 text-amber-50 text-center p-6 mt-12">
        <p>&copy; 2024 MapReduce 대화형 분석. Jeffrey Dean & Sanjay Ghemawat 논문 기반.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Navigation highlighting
            const navLinks = document.querySelectorAll('nav a.nav-link');
            const sections = document.querySelectorAll('main section');

            function changeLinkState() {
                let index = sections.length;
                while(--index && window.scrollY + 100 < sections[index].offsetTop) {}
                
                navLinks.forEach((link) => link.classList.remove('active'));
                if (navLinks[index]) {
                  navLinks[index].classList.add('active');
                }
            }
            changeLinkState(); // Initial call
            window.addEventListener('scroll', changeLinkState);

            // Accordion
            const accordionButtons = document.querySelectorAll('.accordion-button');
            accordionButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const content = button.nextElementSibling;
                    button.classList.toggle('active');
                    content.classList.toggle('active');
                    if (content.classList.contains('active')) {
                        content.style.maxHeight = content.scrollHeight + "px";
                    } else {
                        content.style.maxHeight = null;
                    }
                });
            });
            
            // Tooltip for diagram items - Simplified handling for demo
            // A more robust solution would involve creating and appending tooltips dynamically or using a library
            // For this SPA, we use CSS :hover to show predefined tooltips.

            // Grep Chart
            const grepCtx = document.getElementById('grepChart').getContext('2d');
            new Chart(grepCtx, {
                type: 'line',
                data: {
                    labels: ['0', '20', '30', '40', '50', '60', '70', '80', '100', '150'],
                    datasets: [{
                        label: '입력 데이터 스캔 속도 (MB/s)',
                        data: [0, 2000, 5000, 8000, 22000, 30500, 28000, 0, 0, 0],
                        borderColor: '#0ea5e9', // sky-500
                        backgroundColor: 'rgba(14, 165, 233, 0.1)', // sky-500 with alpha
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { y: { beginAtZero: true, title: { display: true, text: '입력 속도 (MB/s)' } }, x: { title: { display: true, text: '시간 (초)' } } },
                    plugins: { legend: { display: true }, tooltip: { mode: 'index', intersect: false } }
                }
            });

            // Sort Charts Data (approximated from paper figures)
            const sortTimeLabels = Array.from({length: 26}, (_, i) => i * 50); // 0 to 1250s

            const sortData = {
                normal: {
                    input: [0,13000,10000,5000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // peaks at 50s (idx 1), done by 200s (idx 4)
                    shuffle: [0,2000,7000,6000,5000,3000,4000,3000,2000,1000,500,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // first peak ~150s (idx 3), second ~450s (idx 9), done by 600s (idx 12)
                    output: [0,0,0,0,0,0,0,2000,4000,3500,3000,2500,2000,1500,1000,500,0,0,0,0,0,0,0,0,0,0] // starts ~350s (idx 7), ends ~850s (idx 17)
                },
                noBackup: { // Similar start, long tail for output
                    input: [0,13000,10000,5000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    shuffle: [0,2000,7000,6000,5000,3000,4000,3000,2000,1000,500,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    output: [0,0,0,0,0,0,0,2000,3800,3300,2800,2300,1800,1300,800,500,300,200,100,100,50,50,50,50,0,0] // Long tail up to 1283s (idx ~25)
                },
                killed: { // Dip in input, recovers
                    input: [0, 8000, -2000, 10000, 16000, 5000, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // Dip at ~100s (idx 2), recovers, peak ~200s (idx 4)
                    shuffle: [0,1000,5000,7000,6000,4000,3500,2500,1500,800,300,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // Slightly delayed/adjusted
                    output: [0,0,0,0,0,0,0,1800,4200,3700,3200,2700,2200,1700,1200,700,200,0,0,0,0,0,0,0,0,0] // Ends ~933s (idx ~18)
                }
            };
            
            function createSortChart(canvasId, data, label, yLabel) {
                const ctx = document.getElementById(canvasId).getContext('2d');
                return new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortTimeLabels.slice(0, data.length),
                        datasets: [{
                            label: label,
                            data: data,
                            borderColor: '#0ea5e9',
                            backgroundColor: 'rgba(14, 165, 233, 0.1)',
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: { y: { beginAtZero: true, title: { display: true, text: yLabel + ' (MB/s)' } }, x: { title: { display: true, text: '시간 (초)' } } },
                        plugins: { legend: { display: false }, tooltip: { mode: 'index', intersect: false } }
                    }
                });
            }

            let charts = {};
            function renderSortCharts(scenario) {
                if(charts.input) charts.input.destroy();
                if(charts.shuffle) charts.shuffle.destroy();
                if(charts.output) charts.output.destroy();

                charts.input = createSortChart(`sortInputChart${capitalize(scenario)}`, sortData[scenario].input, '입력 속도', '입력');
                charts.shuffle = createSortChart(`sortShuffleChart${capitalize(scenario)}`, sortData[scenario].shuffle, '셔플 속도', '셔플');
                charts.output = createSortChart(`sortOutputChart${capitalize(scenario)}`, sortData[scenario].output, '출력 속도', '출력');
            }
            
            function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

            const sortTabs = {
                normal: document.getElementById('sortChartNormalContainer'),
                noBackup: document.getElementById('sortChartNoBackupContainer'),
                killed: document.getElementById('sortChartKilledContainer'),
            };
            const sortButtons = {
                normal: document.getElementById('sortNormalBtn'),
                noBackup: document.getElementById('sortNoBackupBtn'),
                killed: document.getElementById('sortKilledBtn'),
            };
            
            let currentSortScenario = 'normal';
            renderSortCharts(currentSortScenario); // Initial render

            function switchSortTab(scenario) {
                Object.values(sortTabs).forEach(tab => tab.classList.remove('active'));
                Object.values(sortButtons).forEach(btn => btn.classList.remove('active'));
                
                sortTabs[scenario].classList.add('active');
                sortButtons[scenario].classList.add('active');
                currentSortScenario = scenario;
                renderSortCharts(scenario);
            }

            sortButtons.normal.addEventListener('click', () => switchSortTab('normal'));
            sortButtons.noBackup.addEventListener('click', () => switchSortTab('noBackup'));
            sortButtons.killed.addEventListener('click', () => switchSortTab('killed'));


            // Instances Chart
            const instancesCtx = document.getElementById('instancesChart').getContext('2d');
            new Chart(instancesCtx, {
                type: 'line',
                data: {
                    labels: ['2003/03', '2003/06', '2003/09', '2003/12', '2004/03', '2004/06', '2004/09'],
                    datasets: [{
                        label: 'MapReduce 인스턴스 수',
                        data: [0, 10, 50, 150, 250, 400, 880],
                        borderColor: '#0ea5e9',
                        backgroundColor: 'rgba(14, 165, 233, 0.1)',
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: { y: { beginAtZero: true, title: { display: true, text: '인스턴스 수' } }, x: { title: { display: true, text: '시간' } } },
                    plugins: { legend: { display: true }, tooltip: { mode: 'index', intersect: false } }
                }
            });
        });
    </script>
</body>
</html>